<!doctype html>
<html lang="en">
<head>
	<title>Publish for Web</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="icon" type="image/png" href="images/favicon.png">
	<link rel="stylesheet" type="text/css" href="./css/fonts.css">
	<link rel="stylesheet" type="text/css" href="./css/style.css">
	<script src="./scripts/luxon.min.js"></script>
	<script src="./scripts/jszip.min.js"></script>
</head>

<body>
<h1>Publish for Web</h1>

<div class="all-options">

<div class="option-col">
<fieldset>
<legend>Notes</legend>
<ul>
<li>In the event of name conflicts, file indices will be appended like so: file-1.jpg, file-2.jpg, etc.</li>
</ul>
</fieldset>

<fieldset>
<legend>Template String Format</legend>
<table>
<tr><td>%f</td><td>old file name, no whitespace, lowercase</td></tr>
<tr><td>%F</td><td>old file name, no whitespace, original case</td></tr>
<tr><td>%G</td><td>old file name, original case</td></tr>
<tr><td>%x</td><td>old file extension</td></tr>
<tr><td>%w</td><td>width</td></tr>
<tr><td>%h</td><td>height</td></tr>
<tr><td>%d{FORMAT}</td><td>modtime in the given format</td></tr>
<tr><td>%r{N}</td><td>N random digits</td></tr>
<tr><td>%R{N}</td><td>N random alphanumeric chars</td></tr>
<tr><td>%%</td><td>percent sign</td></tr>
</table>
</fieldset>

<fieldset>
<legend>Date String Format</legend>
<table>
<tr><td>ss</td><td>second, padded to 2</td></tr>
<tr><td>mm</td><td>minute, padded to 2</td></tr>
<tr><td>hh</td><td>hour in 12-hour time, padded to 2</td></tr>
<tr><td>HH</td><td>hour in 24-hour time, padded to 2</td></tr>
<tr><td>a</td><td>meridiem (i.e., AM, PM)</td></tr>
<tr><td>ZZZZ</td><td>abbreviated named offset (e.g., EST)</td></tr>
<tr class="hide-windows"><td>t</td><td>localized time (e.g., 9:07 AM)</td></tr>
<tr class="hide-linux"><td>z</td><td>IANA zone (e.g., America/New_York)</td></tr>
<tr><td>dd</td><td>day of the month, padded to 2</td></tr>
<tr><td>EEE</td><td>day of the week, as an abbreviate localized string (e.g., Wed)</td></tr>
<tr><td>MM</td><td>month as a padded number</td></tr>
<tr><td>y</td><td>year, unpadded</td></tr>
<tr><td>yy</td><td>two-digit year</td></tr>
<tr><td>DD</td><td>localized date with abbreviated month (e.g., Aug 6, 2014)</td></tr>
<tr><td>DDD</td><td>localized date with full month (e.g., August 6, 2014)</td></tr>
<tr class="hide-windows"><td>ff</td><td>localized date and time (e.g., Aug 6, 2014, 1:07 PM)</td></tr>
<tr><td>X</td><td>unix timestamp in seconds (e.g., 1407287224)</td></tr>
<tr><td>x</td><td>unix timestamp in milliseconds</td></tr>
</table>
<p>More options available <a href="https://github.com/moment/luxon/blob/master/docs/formatting.md#table-of-tokens">here</a>. Note that some characters cannot be used for file names depending on your OS.</p>
</fieldset>
</div>

<div class="option-col">

<fieldset>
  <legend>File Name</legend>
  <div>
    <input type="radio" id="filename-whitespace" name="option-filename" value="filename-whitespace" checked />
    <label for="filename-whitespace">Remove whitespace & convert to lowercase</label>
  </div>
  <div>
    <input type="radio" id="filename-template" name="option-filename" value="filename-template" />
    <label for="filename-template" style="margin-right: 10px;">Template:</label>
	<input id="filename-template-text" type="text" value="web-%f-%wx%h" disabled />
  </div>
  <div>
    <input type="radio" id="filename-carry" name="option-filename" value="filename-carry" />
    <label for="filename-carry">No change</label>
  </div>
</fieldset>

<fieldset>
  <legend>Max Dimensions</legend>
  <div>
    <label for="option-dimension-width" style="display: inline-block; width: 50px;">Width:</label>
    <input type="text" id="image-maxwidth" name="option-dimension-width" maxlength="5" length="6" value="1280" />
	<span class="note" style="margin-left: 10px;">(set blank for no limit)</span>
  </div>
  <div>
    <label for="option-dimension-height" style="display: inline-block; width: 50px;">Height:</label>
    <input type="text" id="image-maxheight" name="option-dimension-height" maxlength="5" length="6" value="1024" />
	<span class="note" style="margin-left: 10px;">(set blank for no limit)</span>
  </div>
</fieldset>


<fieldset>
  <legend>Format</legend>
  <div>
    <input type="radio" id="filetype-jpg" name="option-filetype" value="filetype-jpg" checked />
    <label for="filetype-jpg">JPG</label><span class="inline-sep">|</span><span style="margin-right: 10px;">Quality:</span><input id="jpg-quality-text" type="text" length="5" value="0.8" />
  </div>
  <div>
    <input type="radio" id="filetype-png" name="option-filetype" value="filetype-png" />
    <label for="filetype-png">PNG</label>
  </div>
  <div>
    <input type="radio" id="filetype-carry" name="option-filetype" value="filetype-carry" />
    <label for="filetype-carry">No change</label>
  </div>
</fieldset>

<fieldset>
  <legend>Last Modified Time</legend>
  <div>
    <input type="radio" id="modtime-interpret" name="option-modtime" value="modtime-interpret" />
    <label for="modtime-interpret"><span class="tooltip" data-tip="An 8-digit sequence followed by a 6-digit sequence will be interpretted as day and time. The two sequences can be located anywhere as long as they are in that order.">Interpret from filename</span></label>
  </div>
  <div>
    <input type="radio" id="modtime-now" name="option-modtime" value="modtime-now" />
    <label for="modtime-now">Now</label>
  </div>
  <div>
    <input type="radio" id="modtime-set" name="option-modtime" value="modtime-set" />
    <label for="modtime-set" style="margin-right: 10px;">Set:</label>
	<input id="modtime-date-picker" type="datetime-local" disabled />
  </div>
  <div>
    <input type="radio" id="modtime-carry" name="option-modtime" value="modtime-carry" checked />
    <label for="modtime-carry">No change</label>
  </div>
</fieldset>

<fieldset>
<legend>EXIF Metadata</legend>
  <div>
    <label for="option-exif-artist" style="display: inline-block; width: 105px;">Artist:</label>
    <input type="text" id="exif-artist" name="option-exif-artist" />
  </div>
  <div>
    <label for="option-exif-title" style="display: inline-block; width: 105px;">Title:</label>
    <input type="text" id="exif-title" name="option-exif-title" />
  </div>
  <div>
    <label for="option-exif-copyright" style="display: inline-block; width: 105px;">Copyright:</label>
    <input type="text" id="exif-copyright" name="option-exif-copyright" />
  </div>
  <div>
    <label for="option-exif-date" style="display: inline-block; width: 105px;">DateTimeOriginal:</label>
	<select name="option-exif-date" id="exif-date">
	  <option value="exif-date-none">None</option>
	  <option value="exif-date-carry">Read JPG EXIF</option>
	  <option value="exif-date-modtime-old">From old modtime</option>
	  <option value="exif-date-modtime-new">From new modtime</option>
	  <option value="exif-date-interpret">Interpret from filename</option>
	</select>
	<input id="modtime-date-picker" type="datetime-local" />
  </div>
  <div class="center">
  <span class="note">(all other metadata will be removed)</span>
  </div>
</fieldset>

</div>


<div class="option-col">
<fieldset>
<legend>START</legend>
<div>
<input type="file" id="input-files" multiple accept="image/*">
<div class="button" onclick="filePicker(false)">Select Files</div>
<input type="file" id="input-dirs" webkitdirectory multiple accept="image/*">
<div class="button" onclick="filePicker(true)">Select Folders</div>
</div>
<p style="font-size: 14px">Or drag files anywhere</p>
</fieldset>
</div>

</div>



<script>

var DateTime = luxon.DateTime;

const MIME = {
	".jpg" : "image/jpeg",
	".jpeg": "image/jpeg",
	".png" : "image/png",
	".webp": "image/webp", // TODO not supported by canvas.toBlob in Safari
	".zip" : "application/zip",
};


function splitFilename(name) {
	name = name.endsWith("/") ? name.substring(0, name.length-1) : name;
	const lastDotIndex = name.lastIndexOf(".");
	const lastSlashIndex = name.lastIndexOf("/");

	const dir      = lastSlashIndex !== -1 ? name.substring(0, lastSlashIndex+1) : "";
	const basename = lastDotIndex   !== -1 ? name.substring(lastSlashIndex+1, lastDotIndex) : name.substring(lastSlashIndex+1);
	const ext      = lastDotIndex   !== -1 ? name.substring(lastDotIndex     ) : "";
	return [dir, basename, ext];
}

function safeParseInt(str, def) {
  const parsedValue = parseInt(str, 10);
  return isNaN(parsedValue) ? def : parsedValue;
}

function safeParseFloat(str, def) {
  const parsedValue = parseFloat(str, 10);
  return isNaN(parsedValue) ? def : parsedValue;
}

function numberToBytes(num, pad) {
	if (num >= 2**(8*pad)) {
		throw new Error("Overflow");
	}
	const bytes = [];
	for (let i = 0; i < pad; i++) {
		bytes[i] = (num >>> (8*(pad - 1 - i))) & 0xFF;
	}
	return bytes;
}

function saveAs(content, filename) {
	const [dir, basename, ext] = splitFilename(filename);
	const mime = MIME[ext];
	console.log("downloading " + mime);
	const file = new File([content], filename, { type: mime });
	const url = URL.createObjectURL(file);
	const link = document.createElement("a");
	link.href = url;
	link.download = filename;
	link.click(); // TODO % signs are replaced with _
	URL.revokeObjectURL(url);
}









function getRadioValue(groupName) {
	const radioButtons = document.getElementsByName(groupName);
	for (let i = 0; i < radioButtons.length; i++) {
		if (radioButtons[i].checked) {
			//console.log("radio " + groupName + " = " + radioButtons[i].value);
			return radioButtons[i].value;
		}
	}
	return null;
}

function getNewFilename(file) {
	const val = getRadioValue("option-filename");
	let [dir, basename, ext] = splitFilename(file.webkitRelativePath || file.name);

	if (val === "filename-whitespace") {
		basename = basename.trim().toLowerCase().replaceAll(/ +/g, "-");
	} else if (val === "filename-template") {
		let template = document.getElementById("filename-template-text").value;
		let out = "";
		let command = "", arg = "";

		for (let i = 0; i < template.length; i++) {
			let c = template.charAt(i);
			if (command) {
				if (c === "}") {
					if (command === "r") {
						arg = safeParseInt(arg, 1);
						out += Math.floor(Math.random() * 10**arg);
					} else if (command === "R") {
						arg = safeParseInt(arg, 1);
						const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
						for (let j = 0; j < arg; j++) {
							const randomIndex = Math.floor(Math.random() * characters.length);
							out += characters.charAt(randomIndex);
						}
					} else if (command === "d") {
						out += DateTime.fromISO(new Date(file.lastModified).toISOString()).toFormat(arg);
					}
					command = "";
					arg = "";
				} else {
					arg += c;
				}
			} else if (c == "%") {
				i++;
				if (i === template.length) break;
				command = template.charAt(i);
				if (command === "f") {
					out += basename.trim().toLowerCase().replaceAll(/ +/g, "-");
					command = "";
				} else if (command === "F") {
					out += basename.trim().replaceAll(/ +/g, "-");
					command = "";
				} else if (command === "G") {
					out += basename;
					command = "";
				} else if (command === "x") {
					out += ext.substring(1); // old extension
					command = "";
				} else if (command === "w") {
					out += imgDims[file][0];
					command = "";
				} else if (command === "h") {
					out += imgDims[file][1];
					command = "";
				} else if (command === "d") {
					i++;
				} else if (command === "r") {
					i++;
				} else if (command === "R") {
					i++;
				} else if (command === "%") {
					out += "%";
					command = "";
				} else {
					// error, uncrecognized command
					throw new Error("Uncrecognized command in template");
				}
			} else {
				out += c;
			}
		}

		basename = out;
	}
	let format = getNewFormat(file);
	if (format == "image/jpeg") {
		ext = ".jpg";
	} else if (format == "image/png") {
		ext = ".png";
	}
	let name = dir + basename + ext;
	let i = 1;
	while (usedFilenames.has(name)) {
		name = dir + basename + "-" + i + ext;
		i++;
	}
	usedFilenames.add(name);
	return name;
}

function getNewDimensions(img) {
	let newWidth = img.width, newHeight = img.height;
	let maxWidth = parseInt(document.getElementById("image-maxwidth"));
	let maxHeight = parseInt(document.getElementById("image-maxheight"));

	if (isNaN(maxWidth)) {
		maxWidth = img.width;
	}
	if (isNaN(maxHeight)) {
		maxWidth = img.height;
	}

	if (newWidth > maxWidth) {
		newHeight = newHeight * maxWidth / newWidth;
		newWidth = maxWidth;
	}
	if (newHeight > maxHeight) {
		newWidth = newWidth * maxHeight / newHeight;
		newHeight = maxHeight;
	}
	newWidth = Math.floor(newWidth + 0.0001);
	newHeight = Math.floor(newHeight + 0.0001);
	return [newWidth, newHeight];
}

function getNewFormat(file) {
	const val = getRadioValue("option-filetype");
	if (val === "filetype-jpg") {
		return "image/jpeg";
	} else if (val === "filetype-png") {
		return "image/png";
	} else {
		const [dir, basename, ext] = splitFilename(file.name); //drag-and-dropped files don't have a type for some reason, need to look at file ext
		let mime = MIME[ext];
		if (mime === undefined) {
			mime = "image/jpeg";
		}
		return mime;
	}
}

function getNewQuality() {
	let quality = parseFloat(document.getElementById("image-quality"));
	if (isNaN(quality)) {
		quality = 0.8;
	}
	return quality;
}

function getNewModtime(file) {
	const val = getRadioValue("option-modtime");
	let date;
	if (val === "modtime-interpret") {
		const [dir, basename, ext] = splitFilename(file.name);
		const found = basename.replaceAll(/[^\d]/g, " ").trim().match(/^(\d{8}) *(\d{6})$/);
		if (found !== null) {
			const dayNumber = found[1], timeNumber = found[2];
			const year   = parseInt(dayNumber.substring(0, 4));
			const month  = parseInt(dayNumber.substring(4, 6)) - 1; // Months are 0-indexed
			const day    = parseInt(dayNumber.substring(6, 8));
			const hour   = parseInt(timeNumber.substring(0, 2));
			const minute = parseInt(timeNumber.substring(2, 4));
			const second = parseInt(timeNumber.substring(4, 6));
			date = new Date(year, month, day, hour, minute, second);
		}
	} else if (val === "modtime-now") {
		date = new Date();
	} else if (val === "modtime-set") {
		dateval = document.getElementById("modtime-date-picker").value;
		if (dateval !== "")
			date = new Date(dateval);
	} else if (val === "modtime-carry") {
		date = new Date(file.lastModified);
	}
	if (date === null) {
		date = new Date(file.lastModified)
	}
	return date;
}

function getNewEXIFData(file) {
	const artist = document.getElementById("exif-artist").value;
	const title = document.getElementById("exif-title").value;
	const copyright = document.getElementById("exif-copyright").value;
	let dateTimeOriginal = document.getElementById("exif-date").value;
	if (dateTimeOriginal !== "") {
		if (dateTimeOriginal == "exif-date-carry") {
			// TODO read exif date
			dateTimeOriginal = "";
		} else if (dateTimeOriginal == "exif-date-modtime") {
			dateTimeOriginal = DateTime.fromISO(getNewModtime(file).toISOString()).toFormat("yyyy:LL:dd HH:mm:ss");
		} else if (dateTimeOriginal == "exif-date-set") {
			dateTimeOriginal = document.getElementById("exif-date-picker").value;
			dateTimeOriginal = DateTime.fromISO(dateTimeOriginal.toISOString()).toFormat("yyyy:LL:dd HH:mm:ss");
		} else {
			dateTimeOriginal = "";
		}
	}
	console.log(dateTimeOriginal);
	return [artist, title, copyright, dateTimeOriginal];
}


async function insertEXIF(file, blob) {
	// TODO png can also include exif now

	if (blob.type !== "image/jpeg" && blob.type !== "image/png") {
		return blob;
	}

	const [artist, title, copyright, dateTimeOriginal] = getNewEXIFData(file);
	if (!artist && !title && !copyright && !dateTimeOriginal) {
		return blob;
	}

	const encoder = new TextEncoder(); //encoder.encode(str) = uint8array of ascii

	let numberOfEntries = 0;

	const IFD0 = [];
	if (artist) {
		const bytes = Array.from(encoder.encode(artist));
		IFD0.push({
			tag    : [0x01, 0x3B],
			format : [0x00, 0x02],
			length : bytes.length,
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}
	if (title) {
		const bytes = Array.from(encoder.encode(title));
		IFD0.push({
			tag    : [0x01, 0x0E],
			format : [0x00, 0x02],
			length : bytes.length,
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}
	if (copyright) {
		const bytes = Array.from(encoder.encode(copyright));
		IFD0.push({
			tag    : [0x82, 0x98],
			format : [0x00, 0x02],
			length : bytes.length,
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}

	const SubIFD = [];
	if (dateTimeOriginal) {
		const bytes = Array.from(encoder.encode(dateTimeOriginal));
		SubIFD.push({
			tag    : [0x90, 0x03],
			format : [0x00, 0x02],
			length : bytes.length, // max 20 components
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}

	exif = [
		0x4D, 0x4D, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x08, // TIFF header: byte order (big-endian/Motorola) & IFD offset NOTE: ALL offsets are relative to the first 0x4D byte
	];
	exif = exif.concat(numberToBytes(numberOfEntries+1, 2)); // number of entries in IFD0 + 1 for link to IFD1

	exif_data = [];
	offset = 8 + 2 + numberOfEntries*12 + 4; // tiff header + numberOfEntries + IFD0 fields + link to subIFD + link to IFD1

	for (let i = 0; i < IFD0.length; i++) {
		const field = IFD0[i];
		exif = exif.concat(field.tag);
		exif = exif.concat(field.format);
		exif = exif.concat(numberToBytes(field.length, 4));
		if (field.size <= 4) {
			exif = exif.concat(field.data);
		} else {
			exif = exif.concat(numberToBytes(offset, 4));
			exif_data = exif_data.concat(field.data);
			offset += field.size;
		}
	}

	if (SubIFD.length) {
		exif = exif.concat([0x87, 0x69]); // SubIFD tag
		exif = exif.concat([0x00, 0x04]); // format, long uint
		exif = exif.concat([0x00, 0x00, 0x00, 0x01]); // one component
		exif = exif.concat(numberToBytes(offset, 4)); // link

	}

	exif = exif.concat([
		0x00, 0x00, 0x00, 0x00, // pointer to next IFD, all zeros since there is none
	]);

	exif = exif.concat(exif_data);

	// SubIFD

	if (SubIFD.length) {
		exif = exif.concat(numberToBytes(SubIFD.length+1, 2)); // number of entries in SubIFD
		exif_data = [];
		offset += 2 + SubIFD.length*12 + 4; // number of entries + SubIFD fields + end of SubIFD

		for (let i = 0; i < SubIFD.length; i++) {
			const field = SubIFD[i];
			exif = exif.concat(field.tag);
			exif = exif.concat(field.format);
			exif = exif.concat(numberToBytes(field.length, 4));
			if (field.size <= 4) {
				exif = exif.concat(field.data);
			} else {
				exif = exif.concat(numberToBytes(offset, 4));
				exif_data = exif_data.concat(field.data);
				offset += field.size;
			}
		}

		exif = exif.concat([
			0x00, 0x00, 0x00, 0x00, // pointer to next IFD, all zeros since there is none
		]);

		exif = exif.concat(exif_data);
	}

	if (exif.length > 65525) {
		throw new Error("EXIF is too big");
	}

	const jpg_start  = [
		0XFF, 0xD8, // jpg_end start of image
		0xFF, 0xE1, // APP1 header
	]
	.concat(numberToBytes(exif.length+8, 2)) // APP1 header size
	.concat([0x45, 0x78, 0x69, 0x66, 0x00, 0x00,]); // EXIF header (JPG only)
	const jpg_end  = await blob.slice(2).bytes();
	const combinedData = new Uint8Array(jpg_start.length + exif.length + jpg_end.length);
	combinedData.set(jpg_start);
	combinedData.set(exif, jpg_start.length);
	combinedData.set(jpg_end,  jpg_start.length + exif.length);

	return new Blob([combinedData], { type: blob.type });
}






let usedFilenames;
let imgDims;

function processFiles(f) {
	usedFilenames = new Set();
	imgDims = {};
	if (f.length == 1 && !f[0].webkitRelativePath.includes("/")) {
		f = f[0];
		console.log("  beginning file: " + f.name);
		return resizeImage(f)
		.then(blob => {
			return insertEXIF(f, blob);
		})
		.then(exifBlob => {
			const newName = getNewFilename(f);
			console.log("renaming to " + newName);
			saveAs(exifBlob, newName); ////////////// TODO set modtime
		})
		.catch(err => {
			console.log(err);
		});
	} else {
		createZip(f);
	}
}

function resizeImage(file) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = (event) => {
			const img = new Image();
			img.onload = () => {
				const canvas = document.createElement("canvas");
				[newWidth, newHeight] = getNewDimensions(img);

				console.log("    resizing image. width: " + newWidth + " height: " + newHeight);
				canvas.width = newWidth;
				canvas.height = newHeight;
				const ctx = canvas.getContext("2d");
				ctx.drawImage(img, 0, 0, newWidth, newHeight);
				imgDims[file] = [newWidth, newHeight];

				newFormat  = getNewFormat(file);
				newQuality = getNewQuality(file);
				console.log("    converting image: " + newFormat + " " + newQuality);
				canvas.toBlob(blob => {
					resolve(blob);
				}, newFormat, newQuality);
			};
			img.onerror = (error) => {
				reject(error);
			};

			console.log("    interpretting image");
			img.src = event.target.result;
		};
		reader.onerror = (error) => {
			reject(error);
		};

		console.log("  reading file");
		reader.readAsDataURL(file);
	});
}

async function createZip(files) {
	if (!files.length) return;

	const zip = new JSZip();

	console.log("input: " + files.length);
	console.log("compiling zip");

	Promise.all(
		Array.from(files).map(f => {

			console.log("  beginning file: " + f.name + " (" + f.length + ")");
			return resizeImage(f)
			.then(blob => {
				return insertEXIF(f, blob);
			})
			.then(exifBlob => {
				const newName    = getNewFilename(f);
				const newModtime = getNewModtime(f);
				console.log("  adding file: " + newName);
				zip.file(newName, exifBlob, {date: newModtime});
			});
		})
	)
	.then(() => {

		console.log("generating zip");
		zip.generateAsync({ type: "blob", compression: "STORE" })
		.then(content => {
			saveAs(content, "images.zip");
		});
	})
	.catch(err => {
		alert("There was an error reading your files. Make sure they are all valid images.");
		console.log(err);
	});
}

function filePicker(dirs) {
	if (dirs) {
		document.getElementById("input-dirs").click();
	} else {
		document.getElementById("input-files").click();
	}
}

fileInputHandler = (event) => {
	try {
		processFiles(event.target.files);
	} finally {
		event.target.value = '';
	}
}
document.getElementById("input-files").oninput = fileInputHandler;
document.getElementById("input-dirs").oninput = fileInputHandler;

document.addEventListener('dragover', (event) => {
    event.preventDefault();
});

document.addEventListener("drop", (event) => {
	event.preventDefault();
	const items = event.dataTransfer.items;
	const files = [];

	let count = items.length;

	const onFile = (file) => {
		files.push(file);
		if (!--count) processFiles(files);
	}
	const onEntries = (entries) => {
		count += entries.length;
		for (const entry of entries) {
			scanFiles(entry);
		}
		if (!--count) processFiles(files);
	};
	const onErr = (err) => {
		console.log("error: " + f);
		if (!--count) processFiles(files);
	}

	// can scan subdriectories with FileSystemDirectoryEntry, but not with File
	const scanFiles = (entry) => {
		if (entry.isFile) {
			entry.file(onFile, onErr);
		} else {
			entry.createReader().readEntries(onEntries, onErr);
		}
	}

	for (const item of items) {
		const entry = item.webkitGetAsEntry();
		if (entry) {
			scanFiles(entry);
		} else {
			if (!--count) processFiles(files);
		}
	}
}, false);

/*
document.addEventListener("drop", async (event) => {
	event.preventDefault();
	const items = event.dataTransfer.items;
	const allEntries = [];

	// can scan subdriectories with FileSystemDirectoryEntry, but not with File
	const scanFiles = async (entry, allEntries) => {
		if (entry.isFile) {
			allEntries.push(entry);
		} else {
			const reader = entry.createReader();
			const results = await new Promise((resolve, reject) => {
				reader.readEntries(resolve, reject);
			});

			for (const ent of results) {
				await scanFiles(ent, allEntries);
			}
		}
	}

	for (let i = 0; i < items.length; i++) {
		let entry = items[i].webkitGetAsEntry();
		if (entry) {
			await scanFiles(entry, allEntries);
		}
	}

	// convert FileSystemFileEntry's into File's
	// file type is lost for files inside dropped folders
	const files = await Promise.all(allEntries.map(entry =>
		new Promise((resolve, reject) => {
			entry.file(resolve, reject);
		})
	));

	console.log(files);
}, false);
*/














const modtimeChanged = (event) => {
	document.getElementById("modtime-date-picker").disabled = (event.target.value !== "modtime-set");
};
document.getElementById("modtime-interpret").oninput = modtimeChanged;
document.getElementById("modtime-now").oninput = modtimeChanged;
document.getElementById("modtime-set").oninput = modtimeChanged;
document.getElementById("modtime-carry").oninput = modtimeChanged;

const filenameChanged = (event) => {
	document.getElementById("filename-template-text").disabled = (event.target.value !== "filename-template");
};
document.getElementById("filename-whitespace").oninput = filenameChanged;
document.getElementById("filename-template").oninput = filenameChanged;
document.getElementById("filename-carry").oninput = filenameChanged;

const filetypeChanged = (event) => {
	document.getElementById("jpg-quality-text").disabled = (event.target.value !== "filetype-jpg");
};
document.getElementById("filetype-jpg").oninput = filetypeChanged;
document.getElementById("filetype-png").oninput = filetypeChanged;
document.getElementById("filetype-carry").oninput = filetypeChanged;

// TODO check if above radio buttons start off checked

window.addEventListener("DOMContentLoaded", () => {
	if (window.navigator.userAgent.includes("Win")) {
		for (const e of document.querySelectorAll(".hide-windows")) {
			e.style.display = "none";
		}
	} else {
		for (const e of document.querySelectorAll(".hide-linux")) {
			e.style.display = "none";
		}
	}
});

</script>
</body>
</html>
