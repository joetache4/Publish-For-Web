<!doctype html>
<html lang="en">
<head>
	<title>Publish for Web</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="icon" type="image/png" href="images/favicon.png">
	<link rel="stylesheet" type="text/css" href="./css/fonts.css">
	<link rel="stylesheet" type="text/css" href="./css/style.css">
	<script src="./scripts/luxon.min.js"></script>
	<script src="./scripts/fabric.min.js"></script>
	<script src="./scripts/jszip.min.js"></script>
</head>

<body>
<h1>Publish for Web</h1>

<div class="all-options">

<div class="option-col">
<fieldset>
<legend>Template String Format</legend>
<table>
<tr><td>%f</td><td>old file name, no whitespace, lowercase</td></tr>
<tr><td>%F</td><td>old file name, no whitespace, original case</td></tr>
<tr><td>%G</td><td>old file name, original case</td></tr>
<tr><td>%x</td><td>old file extension</td></tr>
<tr><td>%w</td><td>width</td></tr>
<tr><td>%h</td><td>height</td></tr>
<tr><td>%d{FORMAT}</td><td>modtime in the given format <span class="note">(see below)</span></td></tr>
<tr><td>%D{FORMAT}</td><td>today in the given format <span class="note">(see below)</span></td></tr>
<tr><td>%r{N}</td><td>N random digits</td></tr>
<tr><td>%R{N}</td><td>N random alphanumeric chars</td></tr>
<tr><td>%%</td><td>percent sign</td></tr>
</table>
</fieldset>

<fieldset>
<legend>Date Format</legend>
<table>
<tr><td>ss</td><td>second, padded to 2</td></tr>
<tr><td>mm</td><td>minute, padded to 2</td></tr>
<tr><td>hh</td><td>hour in 12-hour time, padded to 2</td></tr>
<tr><td>HH</td><td>hour in 24-hour time, padded to 2</td></tr>
<tr><td>a</td><td>meridiem <span class="note">(i.e., AM, PM)</span></td></tr>
<tr><td>ZZZZ</td><td>abbreviated named offset <span class="note">(e.g., EST)</span></td></tr>
<tr class="hide-windows"><td>t</td><td>localized time <span class="note">(e.g., 9:07 AM)</span></td></tr>
<tr class="hide-linux"><td>z</td><td>IANA zone <span class="note">(e.g., America/New_York)</span></td></tr>
<tr><td>dd</td><td>day of the month, padded to 2</td></tr>
<tr><td>EEE</td><td>day of the week, as an abbreviate localized string <span class="note">(e.g., Wed)</span></td></tr>
<tr><td>MM</td><td>month as a padded number</td></tr>
<tr><td>y</td><td>year, unpadded</td></tr>
<tr><td>yy</td><td>two-digit year</td></tr>
<tr><td>DD</td><td>localized date with abbreviated month <span class="note">(e.g., Aug 6, 2014)</span></td></tr>
<tr><td>DDD</td><td>localized date with full month <span class="note">(e.g., August 6, 2014)</span></td></tr>
<tr class="hide-windows"><td>ff</td><td>localized date and time <span class="note">(e.g., Aug 6, 2014, 1:07 PM)</span></td></tr>
<tr><td>X</td><td>unix timestamp in seconds <span class="note">(e.g., 1407287224)</span></td></tr>
<tr><td>x</td><td>unix timestamp in milliseconds</td></tr>
</table>
<p>More options available <a href="https://github.com/moment/luxon/blob/master/docs/formatting.md#table-of-tokens">here</a>. Note that some characters cannot be used for file names depending on your OS.</p>
</fieldset>
</div>

<div class="option-col">

<fieldset>
  <legend><span class="tooltip" data-tip="In the event of name conflicts, file indices will be appended like so: file.jpg, file-1.jpg, file-2.jpg, etc.">File Name</span></legend>
  <div>
    <input type="radio" id="filename-whitespace" name="option-filename" value="filename-whitespace" checked required />
    <label for="filename-whitespace">Remove whitespace & convert to lowercase</label>
  </div>
  <div>
    <input type="radio" id="filename-template" name="option-filename" value="filename-template" />
    <label for="filename-template">Template:</label>
	<input id="filename-template-text" type="text" value="web-%f-%wx%h" default="web-%f-%wx%h" />
  </div>
  <div>
    <input type="radio" id="filename-carry" name="option-filename" value="filename-carry" />
    <label for="filename-carry">No change</label>
  </div>
</fieldset>

<fieldset>
  <legend>Max Dimensions</legend>
  <div>
    <label for="option-dimension-width" style="display: inline-block; width: 35px;">Width:</label>
    <input type="text" id="image-maxwidth" name="option-dimension-width" maxlength="5" value="1280" />
	<span class="note">(set blank for no limit)</span>
  </div>
  <div>
    <label for="option-dimension-height" style="display: inline-block; width: 35px;">Height:</label>
    <input type="text" id="image-maxheight" name="option-dimension-height" maxlength="5" value="1024" />
	<span class="note">(set blank for no limit)</span>
  </div>
</fieldset>


<fieldset>
  <legend>Format</legend>
  <div>
    <input type="radio" id="filetype-jpg" name="option-filetype" value="filetype-jpg" checked required />
    <label for="filetype-jpg">JPG</label><span style="margin-right: 10px">|</span><span style="margin-right: 10px">Quality:</span><input id="jpg-quality-text" type="text" maxlength="4" value="0.8" default="0.9" style="width:40px" /><span class="note">(a decimal between 0.0 and 1.0)</span>
  </div>
  <div>
    <input type="radio" id="filetype-png" name="option-filetype" value="filetype-png" />
    <label for="filetype-png">PNG</label>
  </div>
  <div>
    <input type="radio" id="filetype-carry" name="option-filetype" value="filetype-carry" />
    <label for="filetype-carry">No change</label>
  </div>
</fieldset>

<fieldset>
  <legend>Last Modified Time</legend>
  <div>
    <input type="radio" id="modtime-interpret" name="option-modtime" value="modtime-interpret" required />
    <label for="modtime-interpret"><span class="tooltip" data-tip="An 8-digit sequence followed by a 6-digit sequence will be interpretted as day and time. The two sequences can be located anywhere as long as they are in that order.">Interpret from filename</span></label>
  </div>
  <div>
    <input type="radio" id="modtime-now" name="option-modtime" value="modtime-now" />
    <label for="modtime-now">Now</label>
  </div>
  <div>
    <input type="radio" id="modtime-set" name="option-modtime" value="modtime-set" />
    <label for="modtime-set">Set:</label>
	<input id="modtime-date-picker" type="datetime-local" step=1 />
  </div>
  <div>
    <input type="radio" id="modtime-carry" name="option-modtime" value="modtime-carry" checked />
    <label for="modtime-carry">No change</label>
  </div>
</fieldset>

<fieldset>
<legend><span class="tooltip" data-tip="Only JPG and PNG images can contain EXIF metadata.">EXIF Metadata</span></legend>
  <div>
    <label for="option-exif-artist" style="display: inline-block; width: 90px;">Artist:</label>
    <input type="text" id="exif-artist" name="option-exif-artist" />
	<span class="note">(blank ignored)</span>
  </div>
  <div>
    <label for="option-exif-title" style="display: inline-block; width: 90px;">Title:</label>
    <input type="text" id="exif-title" name="option-exif-title" />
	<span class="note">(blank ignored)</span>
  </div>
  <div>
    <label for="option-exif-copyright" style="display: inline-block; width: 90px;">Copyright:</label>
    <input type="text" id="exif-copyright" name="option-exif-copyright" />
	<span class="note">(blank ignored)</span>
  </div>
  <div>
    <label for="option-exif-date" style="display: inline-block; width: 90px;">DateTimeOriginal:</label>
	<select name="option-exif-date" id="exif-date">
	  <option value="exif-date-none">None</option>
	  <option value="exif-date-carry">Read JPG EXIF</option>
	  <option value="exif-date-modtime-old">From old modtime</option>
	  <option value="exif-date-modtime-new">From new modtime</option>
	  <option value="exif-date-interpret">Interpret from filename</option>
	</select>
  </div>
  <br>
  <div class="center">
  <span class="note">(all other metadata will be removed)</span>
  </div>
</fieldset>

</div>


<div class="option-col">
<fieldset>
<legend>START</legend>
<br>
<div id="js-off" class="center">
<p style="color: red; font-weight: bold;">Enable Javascript to start.</p>
</div>
<div id="js-on" class="center hidden">
<div>
<input type="file" id="input-files" multiple accept="image/*">
<div class="button" onclick="filePicker(false)">Select Files</div>
<input type="file" id="input-dirs" webkitdirectory multiple accept="image/*">
<div class="button" onclick="filePicker(true)">Select Folders</div>
</div>
<p style="font-size: 14px">Or drag files anywhere</p>
</div>
</fieldset>

<fieldset>
<legend>Progress</legend>
<div class="center" style="height:80px">

</div>
</fieldset>

<div class="center social-links"><div class="img-rescale"><a href="https://github.com/joetache4/Publish-For-Web"><img src="images/github-mark-white.png" /></a></div></div>
</div>

</div>



<script>

var DateTime = luxon.DateTime;

const MIME = {
	".jpg" : "image/jpeg",
	".jpeg": "image/jpeg",
	".png" : "image/png",
	".webp": "image/webp", // TODO not supported by canvas.toBlob in Safari
	".zip" : "application/zip",
};

const PNG_CRC_TABLE = [];
for (let n = 0; n < 256; n++) {
	let c = n;
	for (let k = 0; k < 8; k++) {
		if (c & 1)
			c = 0xedb88320 ^ ((c>>1)&0x7FFFFFFF);
		else
			c = ((c>>1)&0x7FFFFFFF);
	}
	PNG_CRC_TABLE[n] = c;
}

function splitFilename(name) {
	name = name.endsWith("/") ? name.substring(0, name.length-1) : name;
	const lastDotIndex = name.lastIndexOf(".");
	const lastSlashIndex = name.lastIndexOf("/");

	const dir      = lastSlashIndex !== -1 ? name.substring(0, lastSlashIndex+1) : "";
	const basename = lastDotIndex   !== -1 ? name.substring(lastSlashIndex+1, lastDotIndex) : name.substring(lastSlashIndex+1);
	const ext      = lastDotIndex   !== -1 ? name.substring(lastDotIndex     ) : "";
	return [dir, basename, ext];
}

function safeParseInt(str, def) {
  const parsedValue = parseInt(str, 10);
  return isNaN(parsedValue) ? def : parsedValue;
}

function safeParseFloat(str, def) {
  const parsedValue = parseFloat(str, 10);
  return isNaN(parsedValue) ? def : parsedValue;
}

function clamp(num, min, max) {
	return Math.min(Math.max(num, min), max);
}

function numberToBytes(num, pad) {
	if (num >= 2**(8*pad)) {
		throw new Error("Overflow");
	}
	const bytes = [];
	for (let i = 0; i < pad; i++) {
		bytes[i] = (num >>> (8*(pad - 1 - i))) & 0xFF;
	}
	return bytes;
}

function pngCRC(bytes, c = 0xffffffff) {
	for (let n = 0; n < bytes.length; n++) {
		c = PNG_CRC_TABLE[(c ^ bytes[n]) & 0xff] ^ ((c>>8)&0xFFFFFF);
	}
	return c ^ 0xffffffff;
}

/*
alert(numberToBytes(pngCRC([0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x13, 0x88, 0x00, 0x00, 0x13, 0x88, 0x08, 0x02, 0x00, 0x00, 0x00]), 4));
alert([0xd2, 0xfa, 0x10, 0x9c]); // IHDR CRC
let crc = pngCRC([0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x13, 0x88, 0x00, 0x00]);
crc     = pngCRC([0x13, 0x88, 0x08, 0x02, 0x00, 0x00, 0x00], crc ^ 0xffffffff);
alert(numberToBytes(crc, 4));
alert(numberToBytes(pngCRC([0x49, 0x45, 0x4e, 0x44]), 4));
alert([0xae, 0x42, 0x60, 0x82]); // IEND CRC
//*/

function interpretDateFromFilename(file) {
	const [dir, basename, ext] = splitFilename(file.name);
	const found = basename.replaceAll(/[^\d]/g, " ").trim().match(/^(\d{8}) *(\d{6})$/);
	if (found !== null) {
		const dayNumber = found[1], timeNumber = found[2];
		const year   = parseInt(dayNumber.substring(0, 4));
		const month  = parseInt(dayNumber.substring(4, 6)) - 1; // Months are 0-indexed
		const day    = parseInt(dayNumber.substring(6, 8));
		const hour   = parseInt(timeNumber.substring(0, 2));
		const minute = parseInt(timeNumber.substring(2, 4));
		const second = parseInt(timeNumber.substring(4, 6));
		date = new Date(year, month, day, hour, minute, second);
	}
}

// TODO The two problems below are good reasons to only download zip files...
function saveAs(content, filename, modtime=Date.now()) {
	const [dir, basename, ext] = splitFilename(filename);
	const mime = MIME[ext];
	console.log("downloading " + mime + " (" + modtime + ")");
	const file = new File([content], filename, { type: mime, lastModified: modtime }); // lastModified currently has no actual effect
	const url = URL.createObjectURL(file);
	const link = document.createElement("a");
	link.href = url;
	link.download = filename;
	link.click(); // certain characters, including %, will be replaced with _ unless the images are in a .zip
	URL.revokeObjectURL(url);
}

function getRadioValue(groupName) {
	const radioButtons = document.getElementsByName(groupName);
	for (let i = 0; i < radioButtons.length; i++) {
		if (radioButtons[i].checked) {
			return radioButtons[i].value;
		}
	}
	return null;
}

function getInputOrDefault(id) {
	const tag = document.getElementById(id);
	const val = tag.value || tag.getAttribute("default");
	return val;
}

function getLocalDateISOString(localDate=Date.now()) {
	if (typeof localDate === "number") {
		localDate = new Date(localDate);
	}
	const offsetMs = localDate.getTimezoneOffset() * 60 * 1000;
	localDate.setTime(localDate.getTime() - offsetMs);
	localDate =  localDate.toISOString().slice(0, 19);
	return localDate;
}











function getNewFilename(file, width, height) {
	const val = getRadioValue("option-filename");
	let [dir, basename, ext] = splitFilename(file.webkitRelativePath || file.name);

	if (val === "filename-whitespace") {
		basename = basename.trim().toLowerCase().replaceAll(/ +/g, "-");
	} else if (val === "filename-template") {
		const template = getInputOrDefault("filename-template-text");
		let out = "";
		let command = "", arg = "";

		for (let i = 0; i < template.length; i++) {
			let c = template.charAt(i);
			if (command) {
				if (c === "}") {
					if (command === "r") {
						arg = safeParseInt(arg, 1);
						out += Math.floor(Math.random() * 10**arg);
					} else if (command === "R") {
						arg = safeParseInt(arg, 1);
						const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
						for (let j = 0; j < arg; j++) {
							const randomIndex = Math.floor(Math.random() * characters.length);
							out += characters.charAt(randomIndex);
						}
					} else if (command === "d") {
						out += DateTime.fromISO(new Date(getNewModtime(file)).toISOString()).toFormat(arg);
					} else if (command === "D") {
						out += DateTime.fromISO(new Date().toISOString()).toFormat(arg);
					}
					command = "";
					arg = "";
				} else {
					arg += c;
				}
			} else if (c == "%") {
				i++;
				if (i === template.length) break;
				command = template.charAt(i);
				if (command === "f") {
					out += basename.trim().toLowerCase().replaceAll(/ +/g, "-");
					command = "";
				} else if (command === "F") {
					out += basename.trim().replaceAll(/ +/g, "-");
					command = "";
				} else if (command === "G") {
					out += basename;
					command = "";
				} else if (command === "x") {
					out += ext.substring(1); // old extension
					command = "";
				} else if (command === "w") {
					out += width;
					command = "";
				} else if (command === "h") {
					out += height;
					command = "";
				} else if (command === "d") {
					i++;
				} else if (command === "D") {
					i++;
				} else if (command === "r") {
					i++;
				} else if (command === "R") {
					i++;
				} else if (command === "%") {
					out += "%";
					command = "";
				} else {
					// error, uncrecognized command
					throw new Error("Uncrecognized command in template");
				}
			} else {
				out += c;
			}
		}

		basename = out;
	}
	let format = getNewFormat(file);
	if (format == "image/jpeg") {
		ext = ".jpg";
	} else if (format == "image/png") {
		ext = ".png";
	}
	return [dir, basename, ext];
}

function getNewDimensions(img) {
	let newWidth = img.width, newHeight = img.height;
	let maxWidth = parseInt(document.getElementById("image-maxwidth").value);
	let maxHeight = parseInt(document.getElementById("image-maxheight").value);

	if (isNaN(maxWidth)) {
		maxWidth = img.width;
	}
	if (isNaN(maxHeight)) {
		maxWidth = img.height;
	}

	if (newWidth > maxWidth) {
		newHeight = newHeight * maxWidth / newWidth;
		newWidth = maxWidth;
	}
	if (newHeight > maxHeight) {
		newWidth = newWidth * maxHeight / newHeight;
		newHeight = maxHeight;
	}
	newWidth = Math.floor(newWidth + 0.0001);
	newHeight = Math.floor(newHeight + 0.0001);
	return [newWidth, newHeight];
}

function getNewFormat(file) {
	const val = getRadioValue("option-filetype");
	if (val === "filetype-jpg") {
		return "image/jpeg";
	} else if (val === "filetype-png") {
		return "image/png";
	} else {
		const [dir, basename, ext] = splitFilename(file.name); //drag-and-dropped files don't have a type for some reason, need to look at file ext
		let mime = MIME[ext];
		if (mime === undefined) {
			mime = "image/jpeg";
		}
		return mime;
	}
}

function getNewQuality() {
	let quality = parseFloat(getInputOrDefault("jpg-quality-text"));
	quality = clamp(quality, 0.0, 1.0);
	return quality;
}

function getNewModtime(file) {
	const val = getRadioValue("option-modtime");
	let date = null;
	if (val === "modtime-interpret") {
		date = interpretDateFromFilename(file);
	} else if (val === "modtime-now") {
		date = new Date();
	} else if (val === "modtime-set") {
		dateval = document.getElementById("modtime-date-picker").value;
		if (dateval !== "")
			date = new Date(dateval);
	} else if (val === "modtime-carry") {
		date = new Date(file.lastModified);
	}
	if (date === null) {
		date = new Date(file.lastModified)
	}
	return date;
}

function getNewEXIFData(file) {
	const artist = document.getElementById("exif-artist").value;
	const title = document.getElementById("exif-title").value;
	const copyright = document.getElementById("exif-copyright").value;
	let dateTimeOriginal = document.getElementById("exif-date").value;
	if (dateTimeOriginal == "exif-date-carry") {
		// TODO read exif date
		dateTimeOriginal = "";
	} else if (dateTimeOriginal == "exif-date-modtime-old") {
		dateTimeOriginal = getLocalDateISOString(file.lastModified);
		dateTimeOriginal = dateTimeOriginal.replaceAll("-", ":").replace("T", " ");
	} else if (dateTimeOriginal == "exif-date-modtime-new") {
		dateTimeOriginal = getLocalDateISOString(getNewModtime(file));
		dateTimeOriginal = dateTimeOriginal.replaceAll("-", ":").replace("T", " ");
	} else if (dateTimeOriginal == "exif-date-interpret") {
		dateTimeOriginal = getLocalDateISOString(interpretDateFromFilename(file));
		dateTimeOriginal = dateTimeOriginal.replaceAll("-", ":").replace("T", " ");
	} else {
		dateTimeOriginal = "";
	}

	return {
		artist           : artist,
		title            : title,
		copyright        : copyright,
		dateTimeOriginal : dateTimeOriginal
	};
}











function createEXIF(file) {
	const input = getNewEXIFData(file);
	if (!Object.values(input).some(a => a)) {
		return null;
	}

	const encoder = new TextEncoder(); //encoder.encode(str) = uint8array of ascii

	let numberOfEntries = 0;

	const IFD0 = [];
	if (input.artist) {
		const bytes = Array.from(encoder.encode(input.artist));
		IFD0.push({
			tag    : [0x01, 0x3B],
			format : [0x00, 0x02],
			length : bytes.length,
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}
	if (input.title) {
		const bytes = Array.from(encoder.encode(input.title));
		IFD0.push({
			tag    : [0x01, 0x0E],
			format : [0x00, 0x02],
			length : bytes.length,
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}
	if (input.copyright) {
		const bytes = Array.from(encoder.encode(input.copyright));
		IFD0.push({
			tag    : [0x82, 0x98],
			format : [0x00, 0x02],
			length : bytes.length,
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}

	const SubIFD = [];
	if (input.dateTimeOriginal) {
		const bytes = Array.from(encoder.encode(input.dateTimeOriginal));
		SubIFD.push({
			tag    : [0x90, 0x03],
			format : [0x00, 0x02],
			length : bytes.length, // max 20 components
			size   : bytes.length, // 1 byte/component
			data   : bytes
		});
		numberOfEntries++;
	}

	exif = [
		0x4D, 0x4D, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x08, // TIFF header: byte order (big-endian/Motorola) & IFD offset NOTE: ALL offsets are relative to the first 0x4D byte
	];
	exif = exif.concat(numberToBytes(numberOfEntries+1, 2)); // number of entries in IFD0 + 1 for link to IFD1

	exif_data = [];
	offset = 8 + 2 + numberOfEntries*12 + 4; // tiff header + numberOfEntries + IFD0 fields + link to subIFD + link to IFD1

	for (let i = 0; i < IFD0.length; i++) {
		const field = IFD0[i];
		exif = exif.concat(field.tag);
		exif = exif.concat(field.format);
		exif = exif.concat(numberToBytes(field.length, 4));
		if (field.size <= 4) {
			exif = exif.concat(field.data);
		} else {
			exif = exif.concat(numberToBytes(offset, 4));
			exif_data = exif_data.concat(field.data);
			offset += field.size;
		}
	}

	if (SubIFD.length) {
		exif = exif.concat([0x87, 0x69]); // SubIFD tag
		exif = exif.concat([0x00, 0x04]); // format, long uint
		exif = exif.concat([0x00, 0x00, 0x00, 0x01]); // one component
		exif = exif.concat(numberToBytes(offset, 4)); // link

	}

	exif = exif.concat([
		0x00, 0x00, 0x00, 0x00, // pointer to next IFD, all zeros since there is none
	]);

	exif = exif.concat(exif_data);

	// SubIFD

	if (SubIFD.length) {
		exif = exif.concat(numberToBytes(SubIFD.length+1, 2)); // number of entries in SubIFD
		exif_data = [];
		offset += 2 + SubIFD.length*12 + 4; // number of entries + SubIFD fields + end of SubIFD

		for (let i = 0; i < SubIFD.length; i++) {
			const field = SubIFD[i];
			exif = exif.concat(field.tag);
			exif = exif.concat(field.format);
			exif = exif.concat(numberToBytes(field.length, 4));
			if (field.size <= 4) {
				exif = exif.concat(field.data);
			} else {
				exif = exif.concat(numberToBytes(offset, 4));
				exif_data = exif_data.concat(field.data);
				offset += field.size;
			}
		}

		exif = exif.concat([
			0x00, 0x00, 0x00, 0x00, // pointer to next IFD, all zeros since there is none
		]);

		exif = exif.concat(exif_data);
	}

	if (exif.length > 65525) {
		throw new Error("EXIF is too big");
	}

	return exif;
}

// https://www.media.mit.edu/pia/Research/deepview/exif.html
// https://web.archive.org/web/20131018091152/http://exif.org/Exif2-2.PDF
// http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
// https://www.w3.org/TR/png-3/#eXIf
async function insertEXIF(blob, exif, width, height) {
	if (blob.type !== "image/jpeg" && blob.type !== "image/png") {
		return [blob, width, height];
	}
	if (exif === null) {
		return [blob, width, height];
	}

	const dataToCombine = [];
	if (blob.type == "image/jpeg") {

		dataToCombine.push([
			0XFF, 0xD8,                                           // JPG start of image
			0xFF, 0xE1,                                           // APP1 header
		]);
		dataToCombine.push(numberToBytes(exif.length+8, 2));      // APP1 header size
		dataToCombine.push([0x45, 0x78, 0x69, 0x66, 0x00, 0x00]); // EXIF header (JPG only)
		dataToCombine.push(exif);                                 // EXIF Metadata
		const end = await blob.slice(2).bytes();
		dataToCombine.push(end);                                  // Image data
	} else {
		const start = await blob.slice(0, 33).bytes();
		dataToCombine.push(start);                                // PNG header + IHDR
		dataToCombine.push(numberToBytes(exif.length, 4));        // Chunk length
		dataToCombine.push([0x65, 0x58, 0x49, 0x66]);             // EXIF chunk type field
		dataToCombine.push(exif);                                 // EXIF Metadata
		let crc = pngCRC([0x65, 0x58, 0x49, 0x66]);
			crc = pngCRC(exif, crc ^ 0xffffffff);
		dataToCombine.push(numberToBytes(crc, 4));                // CRC
		const end = await blob.slice(33).bytes();                 // Image data
		dataToCombine.push(end);
	}

	let totalLength = 0;
	for (const arr of dataToCombine) {
		totalLength += arr.length;
	}
	let combinedData = new Uint8Array(totalLength);
	let ptr = 0;
	for (const arr of dataToCombine) {
		combinedData.set(arr, ptr);
		ptr += arr.length;
	}

	return [
		new Blob([combinedData], { type: blob.type }),
		width,
		height
	];
}











function processFiles(f) {
	usedFilenames = new Set();
	if (f.length == 1 && !f[0].webkitRelativePath.includes("/")) {
		f = f[0];
		console.log("  beginning file: " + f.name);
		return resizeImage(f)
		.then(resolved => {
			const [blob, width, height] = resolved;
			const exif = createEXIF(f);
			return insertEXIF(blob, exif, width, height);
		})
		.then(resolved => {
			const [exifBlob, width, height] = resolved;
			const newName    = getNewFilename(f, width, height).join("");
			const newModtime = getNewModtime(f).getTime();
			console.log("renaming to " + newName);
			saveAs(exifBlob, newName, newModtime);
		})
		.catch(err => {
			console.log(err);
		});
	} else {
		createZip(f);
	}
}

function createZip(files) {
	if (!files.length) return;

	const zip = new JSZip();
	const usedFilenames = new Set();

	console.log("input: " + files.length);

	Promise.all(
		Array.from(files).map(f => {

			console.log("  beginning file: " + f.name);
			return resizeImage(f)
			.then(resolved => {
				const [blob, width, height] = resolved;
				const exif = createEXIF(f);
				return insertEXIF(blob, exif, width, height);
			})
			.then(resolved => {
				const [exifBlob, width, height] = resolved;
				const [dir, basename, ext] = getNewFilename(f, width, height);
				let newName = [dir, basename, ext].join("");
				for (let i = 1; usedFilenames.has(newName); i++)
					newName = [dir, basename, "-", i, ext].join("");
				usedFilenames.add(newName);
				const newModtime = getNewModtime(f);
				// JSZip assumes UTC
				const offsetMs = newModtime.getTimezoneOffset() * 60 * 1000;
				newModtime.setTime(newModtime.getTime() - offsetMs);
				console.log("  adding file: " + newName);
				zip.file(newName, exifBlob, {date: newModtime});
			});
		})
	)
	.then(() => {

		console.log("generating zip");
		zip.generateAsync({ type: "blob", compression: "STORE" })
		.then(content => {
			saveAs(content, "images.zip");
		});
	})
	.catch(err => {
		alert("There was an error reading your files. Make sure they are all valid images.");
		console.log(err);
	});
}

function resizeImage(file) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = (event) => {
			const img = new Image();
			img.onload = () => {
				const [newWidth, newHeight] = getNewDimensions(img);

				const canvas = document.createElement("canvas");
				const fcanvas = new fabric.Canvas(canvas, {
					imageSmoothingEnabled: false,
					enableRetinaScaling: false,
				});
				fcanvas.setWidth(newWidth);
				fcanvas.setHeight(newHeight);

				const lanczosFilter = new fabric.Image.filters.Resize({
					scaleX: 1,
					scaleY: 1,
					resizeType: "lanczos",
					lanczosLobes: 3,
				});

				const fimg = new fabric.Image(img).scale(newWidth / img.width);
				const r = fcanvas.getRetinaScaling();
				lanczosFilter.scaleX = lanczosFilter.scaleY = fimg.scaleX * r;
				console.log(r);
				fimg.filters = [lanczosFilter];
				fimg.applyFilters();
				fcanvas.add(fimg);
				fcanvas.renderAll();

				const newFormat  = getNewFormat(file);
				const newQuality = getNewQuality(file) ** (1.0/6); // take root b/c lanczos quality seems to increase exponentially

				console.log("    converting image: " + newFormat + " " + newQuality);
				canvas.toBlob(blob => {
					resolve([blob, newWidth, newHeight]);
				}, newFormat, newQuality);
			};
			img.onerror = (error) => {
				reject(error);
			};

			console.log("    interpretting image");
			img.src = event.target.result;
		};
		reader.onerror = (error) => {
			reject(error);
		};

		console.log("  reading file");
		reader.readAsDataURL(file);
	});
}

function filePicker(dirs) {
	if (dirs) {
		document.getElementById("input-dirs").click();
	} else {
		document.getElementById("input-files").click();
	}
}

fileInputHandler = (event) => {
	try {
		processFiles(event.target.files);
	} finally {
		event.target.value = "";
	}
}
document.getElementById("input-files").oninput = fileInputHandler;
document.getElementById("input-dirs").oninput = fileInputHandler;

document.addEventListener("dragover", (event) => {
    event.preventDefault();
});

document.addEventListener("drop", (event) => {
	event.preventDefault();
	const items = event.dataTransfer.items;
	const files = [];

	let count = items.length;

	const onFile = (file) => {
		files.push(file);
		if (!--count) processFiles(files);
	}
	const onEntries = (entries) => {
		count += entries.length;
		for (const entry of entries) {
			scanFiles(entry);
		}
		if (!--count) processFiles(files);
	};
	const onErr = (err) => {
		console.log(err);
		if (!--count) processFiles(files);
	}

	// can scan subdriectories with FileSystemDirectoryEntry, but not with File
	const scanFiles = (entry) => {
		if (entry.isFile) {
			entry.file(onFile, onErr);
		} else {
			entry.createReader().readEntries(onEntries, onErr);
		}
	}

	for (const item of items) {
		const entry = item.webkitGetAsEntry();
		if (entry) {
			scanFiles(entry);
		} else {
			if (!--count) processFiles(files);
		}
	}
}, false);

/*
document.addEventListener("drop", async (event) => {
	event.preventDefault();
	const items = event.dataTransfer.items;
	const allEntries = [];

	// can scan subdriectories with FileSystemDirectoryEntry, but not with File
	const scanFiles = async (entry, allEntries) => {
		if (entry.isFile) {
			allEntries.push(entry);
		} else {
			const reader = entry.createReader();
			const results = await new Promise((resolve, reject) => {
				reader.readEntries(resolve, reject);
			});

			for (const ent of results) {
				await scanFiles(ent, allEntries);
			}
		}
	}

	for (let i = 0; i < items.length; i++) {
		let entry = items[i].webkitGetAsEntry();
		if (entry) {
			await scanFiles(entry, allEntries);
		}
	}

	// convert FileSystemFileEntry's into File's
	// file type is lost for files inside dropped folders
	const files = await Promise.all(allEntries.map(entry =>
		new Promise((resolve, reject) => {
			entry.file(resolve, reject);
		})
	));

	console.log(files);
}, false);
*/











document.querySelectorAll("input[name='option-filename']").forEach(tag => {
	tag.addEventListener("input", (event) => {
		document.getElementById("filename-template-text").disabled = (event.target.value !== "filename-template");
	});
});

document.querySelectorAll("input[name='option-filetype']").forEach(tag => {
	tag.addEventListener("input", (event) => {
		document.getElementById("jpg-quality-text").disabled = (event.target.value !== "filetype-jpg");
	});
});

document.querySelectorAll("input[name='option-modtime']").forEach(tag => {
	tag.addEventListener("input", (event) => {
		document.getElementById("modtime-date-picker").disabled = (event.target.value !== "modtime-set");
	});
});

document.getElementById("filename-template-text").addEventListener("input", (event) => {
	event.target.value = event.target.value.replace(/[^ a-zA-Z0-9!@#$%^&)(_+=\.,-]/g, "");
});

document.getElementById("jpg-quality-text").addEventListener("input", (event) => {
	event.target.value = event.target.value.replace(/[^0-9.]/g, "");
});

document.querySelectorAll("input").forEach(tag => {
	if (tag.getAttribute("default")) {
		tag.addEventListener("blur", (event) => {
			if (tag.value === "") {
				tag.value = tag.getAttribute("default");
			}
		});
	}
});

window.addEventListener("DOMContentLoaded", () => {
	if (window.navigator.userAgent.includes("Win")) {
		for (const e of document.querySelectorAll(".hide-windows")) {
			e.style.display = "none";
		}
	} else {
		for (const e of document.querySelectorAll(".hide-linux")) {
			e.style.display = "none";
		}
	}

	document.getElementById("filename-template-text").disabled = (getRadioValue("option-filename") != "filename-template");
	document.getElementById("jpg-quality-text").disabled = (getRadioValue("option-filetype") != "filetype-jpg");
	document.getElementById("modtime-date-picker").disabled = (getRadioValue("option-modtime") != "modtime-set");

	document.getElementById("modtime-date-picker").value = getLocalDateISOString();

	document.getElementById("js-off").classList.toggle("hidden");
	document.getElementById("js-on").classList.toggle("hidden");
});

</script>
</body>
</html>
